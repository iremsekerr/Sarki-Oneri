# -*- coding: utf-8 -*-
"""SarkiOneri.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17FInZLKujsXztipLge7dkuoYPF0wFNIW
"""

import warnings
warnings.filterwarnings('ignore')
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

from google.colab import drive
drive.mount('/content/drive')

import os
os.environ['VERİ_CONFIG_DIR'] = "/content/drive/My Drive/veri"

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/My Drive/veri

!ls

#veri setimizi okuyoruz
data = pd.read_csv('spotify.csv')
# veri seti içeriğini yazdırıyoruz
print("Veri Seti İçeriği:")
print("------------------------------------------------------------------------------------")
# veri setini ilk beş satırını yazdırdık
data.head()

# data frame in bir özetini yazdırıyoruz
data.info()

# Her sütundaki boş değerlerin sayısını yazdırdık
data.isnull().sum()

# Beliertilen sütunları kaldırarak yeni bir data frame oluşturduk. Bu sütunların kaldırılma nedeni sadece müzik içeriğine göre data frame oluşturmak istememiz.
dataframe = data.drop(columns=['id', 'name', 'artists', 'release_date', 'year'])

# Kolerasyon matrisini hesapladık
dataframe.corr()

# dataframe in sütunları arasında kolerasyon heaplamasının yapılması
kolerasyon = dataframe.corr()

# matplotlib figürünü ayarlanması
f, ax = plt.subplots(figsize=(15, 10))

# Özel bir renk haritasının oluşturulması
cmap = sns.diverging_palette(220, 10, as_cmap=True)

#Isı haritasının doğru en ve boy oranıyla çizilmesi
sns.heatmap(kolerasyon, cmap=cmap, center=0, square=True, linewidths=.5, cbar_kws={"shrink": .5}, ax=ax)

# Grafiğin gösterilmesi
plt.show()

fig, ax = plt.subplots(figsize=(10,6))

# verilerin çizilmesi
ax.scatter(data['tempo'], data['danceability'], color='c')

# Başlık ekleme
ax.set_title('Dans edilebilirlik vs Tempo Grafiği')

# Grafiğin gösterilmesi
plt.show()

# Şeklin aayrlanması
fig, ax = plt.subplots(figsize=(10,6))

# verilerin çizilmesi
ax.scatter(data['energy'], data['popularity'], color='c')

# Başlık ekleme
ax.set_title('Popularite vs Enerji Grafiği')

# Grafiğin gösterilmesi
plt.show()

#Ölçeklendirme için MinMaxScaler kütüphanesinin import edilmesi
from sklearn.preprocessing import MinMaxScaler
#Random forest sınıflandırması yapılması için kütüphanenin import edilmesi
from sklearn.ensemble import RandomForestClassifier

#int16, int32, int64, float16, float32, ve float64 veri türlerinin seçilmesi. Bu veri tiplerinin seçilme nedeni  normalleştirme işleminin sadece sayısal verilerde geçerli olması
datatypes = ['int16', 'int32', 'int64', 'float16', 'float32', 'float64']
normallesme = data.select_dtypes(include=datatypes)

data.dtypes

#MinMaxScaler ın başlatılması
scaler = MinMaxScaler()
#verilerin normalize edilmesi
normallesme_scaled = scaler.fit_transform(normallesme)

# 10 tahmin değeriyle random forest sınıflandırıcısının başlatılması. 
siniflandirici = RandomForestClassifier(n_estimators=10)

siniflandirici.fit(normallesme_scaled, data['key'])

import pickle

# Modeli pickle dosyasına kaydetme
with open('sarkimodeli.pkl', 'wb') as f:
    pickle.dump(siniflandirici, f)

# Modeli dosyadan yükleme
with open('sarkimodeli.pkl', 'rb') as f:
    sarkimodeli = pickle.load(f)

#modelin drivedan okunması
os.environ['SARKİMODELİ_CONFIG_DIR'] = "/content/drive/My Drive/sarkimodeli"
veri= pd.read_pickle('sarkimodeli.pkl')
print(veri)

class Sarki_Oneri():
 #consturctor oluşturulması 
    def __init__(self, dataset):
        self.dataset = dataset
  # Girilen şarkı adına göre şarkıları veren fonksiyon. 
    def oneri(self, sarki, sarki_sayisi=1):
        benzerlik_orani = []
        secili_sarki = self.dataset[(self.dataset.name.str.lower() == sarki.lower())].head(1).values[0]
        oneriler = self.dataset[self.dataset.name.str.lower() != sarki.lower()]
        for r in oneriler.values:
            a = 0
            for i, col in enumerate(oneriler.columns):
                if i not in [1, 6, 12, 14, 18]:
                    a += abs(float(secili_sarki[i]) - float(r[i]))
            benzerlik_orani.append(a)
        oneriler['benzerlik_orani'] = benzerlik_orani
        oneriler = oneriler.sort_values('benzerlik_orani')
        columns = ['artists', 'name']
        return oneriler[columns][:sarki_sayisi]

print("\n\n------------------------------------------------------------------------------------")
istek=input("Sevdiğiniz şarkıya benzer öneriler almak ister misiniz?(E/H): ")
print("------------------------------------------------------------------------------------")
while(istek.upper()=='E'):
    
    asked_song=input("Şarkı ismi girin: ")
    print("------------------------------------------------------------------------------------")
    oneriler = Sarki_Oneri(data)
    print (oneriler.oneri(((asked_song)), 10))
    print("------------------------------------------------------------------------------------")
    istek=input("Tekrar öneri almak ister misiniz?(E/H): ")
    print("------------------------------------------------------------------------------------")